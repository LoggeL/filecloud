import { NextResponse } from 'next/server';
import { getSessionUser } from '@/lib/auth';
import { db } from '@/lib/db';

export async function GET() {
  const user = await getSessionUser();
  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  const data = db.getGraphData(user.id);

  const nodes: any[] = [];
  const edges: any[] = [];
  const edgeSet = new Set<string>();

  function addEdge(source: string, target: string, type: string) {
    const key = `${source}|${target}|${type}`;
    const reverseKey = `${target}|${source}|${type}`;
    if (edgeSet.has(key) || edgeSet.has(reverseKey)) return;
    edgeSet.add(key);
    edges.push({ source, target, type });
  }

  // Folder nodes
  for (const folder of data.folders) {
    nodes.push({ id: `folder-${folder.id}`, label: folder.name, type: 'folder', itemId: folder.id });
    if (folder.parent_id) {
      addEdge(`folder-${folder.parent_id}`, `folder-${folder.id}`, 'contains');
    }
  }

  // Build analysis lookup
  const analyzedFileIds = new Set(data.fileAnalyses.map((fa: any) => fa.file_id));

  // File nodes
  for (const file of data.files) {
    const category = getCategory(file.mime_type);
    nodes.push({
      id: `file-${file.id}`, label: file.original_name, type: 'file',
      category, mimeType: file.mime_type, size: file.size, itemId: file.id,
      analyzed: analyzedFileIds.has(file.id),
    });
    if (file.folder_id) {
      addEdge(`folder-${file.folder_id}`, `file-${file.id}`, 'contains');
    }
  }

  // Share connections → user nodes
  for (const share of data.shares) {
    const nodeId = share.item_type === 'file' ? `file-${share.item_id}` : `folder-${share.item_id}`;
    const userNodeId = `user-${share.shared_with_name}`;
    if (!nodes.find(n => n.id === userNodeId)) {
      nodes.push({ id: userNodeId, label: share.shared_with_name, type: 'user' });
    }
    addEdge(nodeId, userNodeId, 'shared');
  }

  // Entity nodes (from LLM analysis)
  for (const entity of data.entities) {
    nodes.push({
      id: `entity-${entity.id}`, label: entity.name, type: 'entity',
      entityType: entity.type, itemId: entity.id,
    });
  }

  // File → Entity edges
  for (const fe of data.fileEntities) {
    addEdge(`file-${fe.file_id}`, `entity-${fe.entity_id}`, 'extracted_from');
  }

  // Entity → Entity relationships
  for (const rel of data.entityRelationships) {
    addEdge(`entity-${rel.from_entity_id}`, `entity-${rel.to_entity_id}`, rel.type);
  }

  // Tag nodes (from LLM analysis)
  for (const tag of data.tags) {
    const tagNodeId = `tag-${tag.id}`;
    nodes.push({ id: tagNodeId, label: tag.name, type: 'tag', itemId: tag.id, color: tag.color, autoGenerated: !!tag.auto_generated });
  }

  // File → Tag edges
  for (const ft of data.fileTags) {
    addEdge(`file-${ft.file_id}`, `tag-${ft.tag_id}`, 'tagged');
  }

  // Files that share entities → "related" edges
  const entityToFiles: Record<string, string[]> = {};
  for (const fe of data.fileEntities) {
    if (!entityToFiles[fe.entity_id]) entityToFiles[fe.entity_id] = [];
    entityToFiles[fe.entity_id].push(fe.file_id);
  }
  for (const fileIds of Object.values(entityToFiles)) {
    if (fileIds.length < 2) continue;
    for (let i = 0; i < fileIds.length; i++) {
      for (let j = i + 1; j < fileIds.length; j++) {
        addEdge(`file-${fileIds[i]}`, `file-${fileIds[j]}`, 'related');
      }
    }
  }

  // Also add category-based tags for files without LLM tags
  const tagMap: Record<string, string[]> = {};
  for (const file of data.files) {
    if (!data.fileTags.some((ft: any) => ft.file_id === file.id)) {
      const cat = getCategory(file.mime_type);
      if (!tagMap[cat]) tagMap[cat] = [];
      tagMap[cat].push(`file-${file.id}`);
    }
  }
  for (const [tag, fileIds] of Object.entries(tagMap)) {
    if (fileIds.length > 1) {
      const tagNodeId = `cattag-${tag}`;
      if (!nodes.find(n => n.id === tagNodeId)) {
        nodes.push({ id: tagNodeId, label: tag, type: 'tag' });
      }
      for (const fid of fileIds) {
        addEdge(fid, tagNodeId, 'tagged');
      }
    }
  }

  // Analysis stats
  const stats = db.getAnalysisStats(user.id);

  return NextResponse.json({ nodes, edges, stats });
}

function getCategory(mime: string): string {
  if (mime.startsWith('image/')) return 'Images';
  if (mime.startsWith('video/')) return 'Videos';
  if (mime.startsWith('audio/')) return 'Audio';
  if (mime === 'application/pdf') return 'Documents';
  if (mime.includes('text') || mime.includes('json') || mime.includes('xml') || mime.includes('javascript')) return 'Code';
  if (mime.includes('zip') || mime.includes('archive') || mime.includes('tar')) return 'Archives';
  return 'Other';
}
